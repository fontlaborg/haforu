Based on the attached files and research, I'll now provide a comprehensive analysis of the optimal rasterization path for haforu.

## Haforu Rasterization Strategy: Ultrafast Text+Font → Bitmap in Rust

The haforu project aims to build a high-performance font shaping and rendering system capable of handling **hundreds of thousands of font instances** with **ultra-fast, low-memory rasterization**. Given the indicated tech stack (read-fonts, skrifa, harfrust, parley, vello) and the focus on speed over complex compositing, here's the optimal path:

### Core Architecture Choice

**Use skrifa for outline extraction + zeno for CPU rasterization** as the primary path, with optional vello GPU acceleration for batch workloads.[1][2]

### Recommended Pipeline

**Phase 1: Font Loading (Zero-Copy)**
- Use `read-fonts` with `memmap2` for memory-mapped font access (already in your stack)[3]
- Cache `FontRef` objects with LRU eviction (256 fonts default, as specified in TODO)[3]
- For variable fonts, pre-compute instance locations and cache `skrifa::Instance` objects
- Avoid copying font data—work directly with memory-mapped views

**Phase 2: Shaping (Parallelizable)**
- Use `harfrust` for text shaping to get glyph IDs, advances, and positions[4][3]
- This outputs glyph sequences with cluster information
- Batch shaping operations across multiple texts using Rayon[3]

**Phase 3: Outline Extraction (Critical Path)**
- Use `skrifa::outline::DrawSettings` to extract glyph outlines[5]
- skrifa provides zero-copy access to glyph data from TrueType/CFF/CFF2
- For variable fonts, skrifa handles delta computation efficiently
- **Key optimization**: Cache frequently-used glyph outlines at specific sizes/variations

**Phase 4: Rasterization (The Performance Bottleneck)**

For your use case (hundreds of thousands of instances, no complex compositing), choose:

**Option A: zeno (Recommended for CPU-bound workloads)**[2][1]
- Pure Rust, high-performance 2D path rasterizer
- 256x anti-aliased rendering (8-bit alpha)
- Minimal memory footprint
- **Parallelizable**: Rasterize different glyphs/texts on different threads via Rayon
- No GPU dependencies, predictable performance
- Fast enough for glyph atlas generation

```rust
use zeno::{Mask, PathData, Format};
use skrifa::outline::{DrawSettings, OutlinePen};

// Convert skrifa outline to zeno path
let mut path_builder = PathBuilder::new();
let pen = ZenoPen::new(&mut path_builder);
glyph.draw(DrawSettings::default(), &pen)?;

// Rasterize with zeno
let (mask, placement) = Mask::new(&path_builder.finish())
    .size(width, height)
    .format(Format::Alpha) // 8-bit alpha, not subpixel
    .render();
```

**Option B: vello (For GPU-accelerated batch processing)**[5][3]
- Already in your stack
- GPU compute-based rendering (D3D11-level features)
- **Best for**: Large batches rendered together (e.g., 10,000 texts → single GPU pass)
- Higher setup cost but scales better for massive parallelism
- Use when rendering many instances to a shared atlas

**Option C: swash (Alternative CPU rasterizer)**[6][7]
- Pure Rust, integrated with fontdb
- Handles variable fonts and color fonts (COLRv1)
- More feature-complete than zeno but potentially heavier
- Use if you need color emoji or complex font features

### Memory Optimization Strategy

**For hundreds of thousands of font instances:**

1. **Shared Glyph Atlas** (Critical)[3]
   - Pre-rasterize common glyphs at popular sizes
   - Store in memory-mapped packfiles with zstd compression[3]
   - Use LRU cache for hot glyphs
   - Format: `{glyph_id}_{font_hash}_{size}_{variation_hash}` → bitmap

2. **Lazy Rasterization**
   - Only rasterize on first use
   - Store metadata (advance, bbox) separately from pixels
   - Use 16-bit image offsets for compact atlas indexing

3. **Memory-Mapped Storage**[3]
   - Sharded packfiles (2-10 GiB per shard)
   - Binary search index for O(1) lookup
   - mmap allows OS to manage paging
   - Estimated: ~50-100 bytes per glyph entry (including overhead)

4. **Parallelization with Rayon**[3]
   - Thread pool sized to CPU cores
   - Work-stealing queue for load balancing
   - Pipeline: font loading → shaping → outline extraction → rasterization → storage
   - Each stage can run in parallel across different text batches

### Performance Characteristics

**Expected throughput** (single-threaded, CPU rasterization):
- Simple glyphs (ASCII): ~50,000-100,000 glyphs/sec[4]
- Complex glyphs (CJK, Arabic): ~10,000-30,000 glyphs/sec
- With 64-core parallelism: 500K-6M glyphs/sec theoretical peak

**Memory footprint per instance**:
- Font metadata: ~200 bytes
- Shaped text: ~20 bytes/glyph (glyph ID + position)
- Cached outline: ~500-2000 bytes/glyph (variable)
- Rasterized bitmap: ~1-16 KB/glyph (size-dependent)

**Storage**: For 10M image corpus at ~4KB average → ~40 GB compressed with zstd[3]

### Critical Optimizations

1. **Avoid Double-Parsing**: Use skrifa's `FontRef` directly from `read-fonts`—they're designed to interoperate[5]
2. **SIMD in Rasterization**: zeno uses SIMD internally; ensure you compile with `target-cpu=native`
3. **Batch Coordinate Transformations**: Apply affine transforms before rasterization, not after
4. **Early Culling**: Check glyph bounding boxes before rasterization
5. **Subpixel Positioning**: Quantize glyph positions to 1/4 or 1/8 pixel to reduce cache misses

### Why NOT Other Options

- **FreeType**: C dependency, harder to parallelize safely, GPL licensing issues[8]
- **pathfinder**: GPU-focused, higher overhead for small glyphs, abandoned[9][10]
- **Direct vello for all**: Too much overhead per-glyph; better for scene-level rendering[5]
- **fontdue**: Limited to simple fonts, no variable font support[11]

### Implementation Roadmap Adjustment

Based on your TODO.md, I recommend:[3]

1. **Phase 1**: Font loading (memmap2) + harfrust shaping → **Done**
2. **Phase 2**: skrifa outline extraction + zeno rasterization → **Priority: Critical**
3. **Phase 3**: Rayon parallelization + glyph cache → **Priority: High**
4. **Phase 4**: Sharded packfile storage (already planned)
5. **Phase 5**: Optional vello GPU path for batch mode → **Priority: Low**

### Final Answer

**The most efficient path is: `read-fonts` (memory-mapped) → `harfrust` (shaping) → `skrifa` (outline extraction) → `zeno` (CPU rasterization) → parallel storage with Rayon.** This minimizes memory copies, maximizes parallelism, and avoids GPU overhead for small per-glyph operations. For massive batch rendering (10K+ texts at once), add vello as an alternativeative backend.

[1](https://github.com/dfrg/zeno)
[2](https://docs.rs/zeno)
[3](https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/106844374/852f9c3a-98ee-49b5-95c4-62afa7d3730b/llms.txt)
[4](https://github.com/harfbuzz/rustybuzz)
[5](https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/106844374/79a0e007-1520-492d-8212-bbdeca8a456e/01code-tldr.txt)
[6](https://www.reddit.com/r/rust/comments/n16kod/swash_complex_text_shaping_and_glyph/)
[7](https://lib.rs/crates/swash)
[8](https://news.ycombinator.com/item?id=43418227)
[9](https://nical.github.io/posts/a-look-at-pathfinder.html)
[10](https://github.com/servo/pathfinder)
[11](https://github.com/RazrFalcon/tiny-skia/issues/1)
[12](https://docs.rs/ramp-text)
[13](https://crates.io/crates/cosmic-text/0.14.2)
[14](https://www.youtube.com/watch?v=HzjgpxYbw78)
[15](https://docs.rs/salvation-cosmic-text)
[16](https://www.reddit.com/r/Amd/comments/1dqn7xn/rasterization_didnt_just_die_it_was_murdered_in/)
[17](https://github.com/googlefonts/oxidize)
[18](https://stackoverflow.com/questions/79086136/how-to-resolve-difference-in-font-rendering-between-chrome-on-windows-chromium)
[19](https://docs.aspose.com/font/net/font-rasterization/)
[20](https://docs.rs/rustybuzz/)
[21](https://www.reddit.com/r/opengl/comments/1gfe2vc/font_rendering_using_texture_atlas_which_is_the/)